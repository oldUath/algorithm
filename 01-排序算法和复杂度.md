    稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。

    不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。

    时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。

    空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

# 冒泡排序
都是：从小到大排序

冒泡排序是两两比较，前面的比后面的大就交换位置，再与后面的比较,最大值跑到了最后面，确定了位置

双层循环，外层控制趟数 `arr.length-1`，内层控制每趟比较几次 `arr.length-i-1`

````js
function bullueSort(arr){
    if(arr.length == 1){
        return arr
    }
    //i控制趟数
    for(var i=0;i<arr.length-1;i++){
        //比较几次
        for(var j=0;j<arr.length-i-1;j++){
            if(arr[j]>arr[j+1]){
                var mid = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = mid
            }
        }
    }
    return arr
}
console.log(bullueSort([5,8,1,5,6,9,0]))

// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 -- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定
````

# 选择排序
选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
```js
function selectionSort(arr){
    if(arr.length == 1){
        return arr
    }
    var temp,minIndex;
    for(var i=0;i<arr.length-1;i++){
        minIndex=i;
        for(var j=i+1;j<arr.length;j++){
            if(arr[j]<arr[minIndex]){
                //获取最小值的索引
                minIndex = j;
            }
        }
        //arr[minIndex]为最小值，放到前面
        temp = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = temp
    }
    return arr
}
console.log(selectionSort([5,8,1,5,6,9,0]))

// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- O(n^2)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 不稳定
```

# 插入排序
原理和打扑克，抓拍一样

从第一个元素开始，该元素可以认为已经被排序

取出下一个元素，在已经排序的元素序列中从后向前扫描

如果该元素（已排序）大于新元素，将该元素移到下一位置

重复步骤3，直到找到已排序的元素小于或者等于新元素的位置

将新元素插入到该位置后

重复步骤2~5
```js
function insertSort(arr){
    var preIndex,current;
    for(var i=1;i<arr.length;i++){
        preIndex = i-1 //左手已经排好顺序的牌
        current = arr[i] //右手手里拿到的牌
        while(preIndex>=0&&arr[preIndex]>current){
            //如果左手从有数的牌，比右手的牌大，就将左手的牌向右移动
            arr[preIndex+1]=arr[preIndex];
            preIndex--
        }
        arr[preIndex+1]=current
    }
    return arr;
}
console.log(insertSort([5,8,1,5,6,9,0]))
// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定
```