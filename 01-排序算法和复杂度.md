    稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。

    不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。

    时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。

    空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

# 冒泡排序
都是：从小到大排序

冒泡排序是两两比较，前面的比后面的大就交换位置，再与后面的比较,最大值跑到了最后面，确定了位置

双层循环，外层控制趟数 `arr.length-1`，内层控制每趟比较几次 `arr.length-i-1`

````js
function bullueSort(arr){
    if(arr.length == 1){
        return arr
    }
    //i控制趟数
    for(var i=0;i<arr.length-1;i++){
        //比较几次
        for(var j=0;j<arr.length-i-1;j++){
            if(arr[j]>arr[j+1]){
                var mid = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = mid
            }
        }
    }
    return arr
}
console.log(bullueSort([5,8,1,5,6,9,0]))

// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定
````

# 选择排序
选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
```js
function selectionSort(arr){
    if(arr.length == 1){
        return arr
    }
    var temp,minIndex;
    for(var i=0;i<arr.length-1;i++){
        minIndex=i;
        for(var j=i+1;j<arr.length;j++){
            if(arr[j]<arr[minIndex]){
                //获取最小值的索引
                minIndex = j;
            }
        }
        //arr[minIndex]为最小值，放到前面
        temp = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = temp
    }
    return arr
}
console.log(selectionSort([5,8,1,5,6,9,0]))

// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- O(n^2)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 不稳定
```